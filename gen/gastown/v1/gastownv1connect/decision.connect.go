// Code generated by protoc-gen-connect-go. DO NOT EDIT.
//
// Source: gastown/v1/decision.proto

package gastownv1connect

import (
	connect "connectrpc.com/connect"
	context "context"
	errors "errors"
	v1 "github.com/steveyegge/gastown/gen/gastown/v1"
	http "net/http"
	strings "strings"
)

// This is a compile-time assertion to ensure that this generated file and the connect package are
// compatible. If you get a compiler error that this constant is not defined, this code was
// generated with a version of connect newer than the one compiled into your binary. You can fix the
// problem by either regenerating this code with an older version of connect or updating the connect
// version compiled into your binary.
const _ = connect.IsAtLeastVersion1_13_0

const (
	// DecisionServiceName is the fully-qualified name of the DecisionService service.
	DecisionServiceName = "gastown.v1.DecisionService"
)

// These constants are the fully-qualified names of the RPCs defined in this package. They're
// exposed at runtime as Spec.Procedure and as the final two segments of the HTTP route.
//
// Note that these are different from the fully-qualified method names used by
// google.golang.org/protobuf/reflect/protoreflect. To convert from these constants to
// reflection-formatted method names, remove the leading slash and convert the remaining slash to a
// period.
const (
	// DecisionServiceListPendingProcedure is the fully-qualified name of the DecisionService's
	// ListPending RPC.
	DecisionServiceListPendingProcedure = "/gastown.v1.DecisionService/ListPending"
	// DecisionServiceGetDecisionProcedure is the fully-qualified name of the DecisionService's
	// GetDecision RPC.
	DecisionServiceGetDecisionProcedure = "/gastown.v1.DecisionService/GetDecision"
	// DecisionServiceCreateDecisionProcedure is the fully-qualified name of the DecisionService's
	// CreateDecision RPC.
	DecisionServiceCreateDecisionProcedure = "/gastown.v1.DecisionService/CreateDecision"
	// DecisionServiceResolveProcedure is the fully-qualified name of the DecisionService's Resolve RPC.
	DecisionServiceResolveProcedure = "/gastown.v1.DecisionService/Resolve"
	// DecisionServiceCancelProcedure is the fully-qualified name of the DecisionService's Cancel RPC.
	DecisionServiceCancelProcedure = "/gastown.v1.DecisionService/Cancel"
	// DecisionServiceWatchDecisionsProcedure is the fully-qualified name of the DecisionService's
	// WatchDecisions RPC.
	DecisionServiceWatchDecisionsProcedure = "/gastown.v1.DecisionService/WatchDecisions"
)

// DecisionServiceClient is a client for the gastown.v1.DecisionService service.
type DecisionServiceClient interface {
	// ListPending returns all pending decisions
	ListPending(context.Context, *connect.Request[v1.ListPendingRequest]) (*connect.Response[v1.ListPendingResponse], error)
	// GetDecision returns a specific decision
	GetDecision(context.Context, *connect.Request[v1.GetDecisionRequest]) (*connect.Response[v1.GetDecisionResponse], error)
	// CreateDecision creates a new decision request
	// This is the primary way to create decisions when gtmobile is running,
	// enabling real-time notification via the event bus.
	CreateDecision(context.Context, *connect.Request[v1.CreateDecisionRequest]) (*connect.Response[v1.CreateDecisionResponse], error)
	// Resolve resolves a decision with the chosen option
	Resolve(context.Context, *connect.Request[v1.ResolveRequest]) (*connect.Response[v1.ResolveResponse], error)
	// Cancel cancels a pending decision
	Cancel(context.Context, *connect.Request[v1.CancelRequest]) (*connect.Response[v1.CancelResponse], error)
	// WatchDecisions streams new decision requests
	WatchDecisions(context.Context, *connect.Request[v1.WatchDecisionsRequest]) (*connect.ServerStreamForClient[v1.Decision], error)
}

// NewDecisionServiceClient constructs a client for the gastown.v1.DecisionService service. By
// default, it uses the Connect protocol with the binary Protobuf Codec, asks for gzipped responses,
// and sends uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the
// connect.WithGRPC() or connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewDecisionServiceClient(httpClient connect.HTTPClient, baseURL string, opts ...connect.ClientOption) DecisionServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	decisionServiceMethods := v1.File_gastown_v1_decision_proto.Services().ByName("DecisionService").Methods()
	return &decisionServiceClient{
		listPending: connect.NewClient[v1.ListPendingRequest, v1.ListPendingResponse](
			httpClient,
			baseURL+DecisionServiceListPendingProcedure,
			connect.WithSchema(decisionServiceMethods.ByName("ListPending")),
			connect.WithClientOptions(opts...),
		),
		getDecision: connect.NewClient[v1.GetDecisionRequest, v1.GetDecisionResponse](
			httpClient,
			baseURL+DecisionServiceGetDecisionProcedure,
			connect.WithSchema(decisionServiceMethods.ByName("GetDecision")),
			connect.WithClientOptions(opts...),
		),
		createDecision: connect.NewClient[v1.CreateDecisionRequest, v1.CreateDecisionResponse](
			httpClient,
			baseURL+DecisionServiceCreateDecisionProcedure,
			connect.WithSchema(decisionServiceMethods.ByName("CreateDecision")),
			connect.WithClientOptions(opts...),
		),
		resolve: connect.NewClient[v1.ResolveRequest, v1.ResolveResponse](
			httpClient,
			baseURL+DecisionServiceResolveProcedure,
			connect.WithSchema(decisionServiceMethods.ByName("Resolve")),
			connect.WithClientOptions(opts...),
		),
		cancel: connect.NewClient[v1.CancelRequest, v1.CancelResponse](
			httpClient,
			baseURL+DecisionServiceCancelProcedure,
			connect.WithSchema(decisionServiceMethods.ByName("Cancel")),
			connect.WithClientOptions(opts...),
		),
		watchDecisions: connect.NewClient[v1.WatchDecisionsRequest, v1.Decision](
			httpClient,
			baseURL+DecisionServiceWatchDecisionsProcedure,
			connect.WithSchema(decisionServiceMethods.ByName("WatchDecisions")),
			connect.WithClientOptions(opts...),
		),
	}
}

// decisionServiceClient implements DecisionServiceClient.
type decisionServiceClient struct {
	listPending    *connect.Client[v1.ListPendingRequest, v1.ListPendingResponse]
	getDecision    *connect.Client[v1.GetDecisionRequest, v1.GetDecisionResponse]
	createDecision *connect.Client[v1.CreateDecisionRequest, v1.CreateDecisionResponse]
	resolve        *connect.Client[v1.ResolveRequest, v1.ResolveResponse]
	cancel         *connect.Client[v1.CancelRequest, v1.CancelResponse]
	watchDecisions *connect.Client[v1.WatchDecisionsRequest, v1.Decision]
}

// ListPending calls gastown.v1.DecisionService.ListPending.
func (c *decisionServiceClient) ListPending(ctx context.Context, req *connect.Request[v1.ListPendingRequest]) (*connect.Response[v1.ListPendingResponse], error) {
	return c.listPending.CallUnary(ctx, req)
}

// GetDecision calls gastown.v1.DecisionService.GetDecision.
func (c *decisionServiceClient) GetDecision(ctx context.Context, req *connect.Request[v1.GetDecisionRequest]) (*connect.Response[v1.GetDecisionResponse], error) {
	return c.getDecision.CallUnary(ctx, req)
}

// CreateDecision calls gastown.v1.DecisionService.CreateDecision.
func (c *decisionServiceClient) CreateDecision(ctx context.Context, req *connect.Request[v1.CreateDecisionRequest]) (*connect.Response[v1.CreateDecisionResponse], error) {
	return c.createDecision.CallUnary(ctx, req)
}

// Resolve calls gastown.v1.DecisionService.Resolve.
func (c *decisionServiceClient) Resolve(ctx context.Context, req *connect.Request[v1.ResolveRequest]) (*connect.Response[v1.ResolveResponse], error) {
	return c.resolve.CallUnary(ctx, req)
}

// Cancel calls gastown.v1.DecisionService.Cancel.
func (c *decisionServiceClient) Cancel(ctx context.Context, req *connect.Request[v1.CancelRequest]) (*connect.Response[v1.CancelResponse], error) {
	return c.cancel.CallUnary(ctx, req)
}

// WatchDecisions calls gastown.v1.DecisionService.WatchDecisions.
func (c *decisionServiceClient) WatchDecisions(ctx context.Context, req *connect.Request[v1.WatchDecisionsRequest]) (*connect.ServerStreamForClient[v1.Decision], error) {
	return c.watchDecisions.CallServerStream(ctx, req)
}

// DecisionServiceHandler is an implementation of the gastown.v1.DecisionService service.
type DecisionServiceHandler interface {
	// ListPending returns all pending decisions
	ListPending(context.Context, *connect.Request[v1.ListPendingRequest]) (*connect.Response[v1.ListPendingResponse], error)
	// GetDecision returns a specific decision
	GetDecision(context.Context, *connect.Request[v1.GetDecisionRequest]) (*connect.Response[v1.GetDecisionResponse], error)
	// CreateDecision creates a new decision request
	// This is the primary way to create decisions when gtmobile is running,
	// enabling real-time notification via the event bus.
	CreateDecision(context.Context, *connect.Request[v1.CreateDecisionRequest]) (*connect.Response[v1.CreateDecisionResponse], error)
	// Resolve resolves a decision with the chosen option
	Resolve(context.Context, *connect.Request[v1.ResolveRequest]) (*connect.Response[v1.ResolveResponse], error)
	// Cancel cancels a pending decision
	Cancel(context.Context, *connect.Request[v1.CancelRequest]) (*connect.Response[v1.CancelResponse], error)
	// WatchDecisions streams new decision requests
	WatchDecisions(context.Context, *connect.Request[v1.WatchDecisionsRequest], *connect.ServerStream[v1.Decision]) error
}

// NewDecisionServiceHandler builds an HTTP handler from the service implementation. It returns the
// path on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewDecisionServiceHandler(svc DecisionServiceHandler, opts ...connect.HandlerOption) (string, http.Handler) {
	decisionServiceMethods := v1.File_gastown_v1_decision_proto.Services().ByName("DecisionService").Methods()
	decisionServiceListPendingHandler := connect.NewUnaryHandler(
		DecisionServiceListPendingProcedure,
		svc.ListPending,
		connect.WithSchema(decisionServiceMethods.ByName("ListPending")),
		connect.WithHandlerOptions(opts...),
	)
	decisionServiceGetDecisionHandler := connect.NewUnaryHandler(
		DecisionServiceGetDecisionProcedure,
		svc.GetDecision,
		connect.WithSchema(decisionServiceMethods.ByName("GetDecision")),
		connect.WithHandlerOptions(opts...),
	)
	decisionServiceCreateDecisionHandler := connect.NewUnaryHandler(
		DecisionServiceCreateDecisionProcedure,
		svc.CreateDecision,
		connect.WithSchema(decisionServiceMethods.ByName("CreateDecision")),
		connect.WithHandlerOptions(opts...),
	)
	decisionServiceResolveHandler := connect.NewUnaryHandler(
		DecisionServiceResolveProcedure,
		svc.Resolve,
		connect.WithSchema(decisionServiceMethods.ByName("Resolve")),
		connect.WithHandlerOptions(opts...),
	)
	decisionServiceCancelHandler := connect.NewUnaryHandler(
		DecisionServiceCancelProcedure,
		svc.Cancel,
		connect.WithSchema(decisionServiceMethods.ByName("Cancel")),
		connect.WithHandlerOptions(opts...),
	)
	decisionServiceWatchDecisionsHandler := connect.NewServerStreamHandler(
		DecisionServiceWatchDecisionsProcedure,
		svc.WatchDecisions,
		connect.WithSchema(decisionServiceMethods.ByName("WatchDecisions")),
		connect.WithHandlerOptions(opts...),
	)
	return "/gastown.v1.DecisionService/", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch r.URL.Path {
		case DecisionServiceListPendingProcedure:
			decisionServiceListPendingHandler.ServeHTTP(w, r)
		case DecisionServiceGetDecisionProcedure:
			decisionServiceGetDecisionHandler.ServeHTTP(w, r)
		case DecisionServiceCreateDecisionProcedure:
			decisionServiceCreateDecisionHandler.ServeHTTP(w, r)
		case DecisionServiceResolveProcedure:
			decisionServiceResolveHandler.ServeHTTP(w, r)
		case DecisionServiceCancelProcedure:
			decisionServiceCancelHandler.ServeHTTP(w, r)
		case DecisionServiceWatchDecisionsProcedure:
			decisionServiceWatchDecisionsHandler.ServeHTTP(w, r)
		default:
			http.NotFound(w, r)
		}
	})
}

// UnimplementedDecisionServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedDecisionServiceHandler struct{}

func (UnimplementedDecisionServiceHandler) ListPending(context.Context, *connect.Request[v1.ListPendingRequest]) (*connect.Response[v1.ListPendingResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("gastown.v1.DecisionService.ListPending is not implemented"))
}

func (UnimplementedDecisionServiceHandler) GetDecision(context.Context, *connect.Request[v1.GetDecisionRequest]) (*connect.Response[v1.GetDecisionResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("gastown.v1.DecisionService.GetDecision is not implemented"))
}

func (UnimplementedDecisionServiceHandler) CreateDecision(context.Context, *connect.Request[v1.CreateDecisionRequest]) (*connect.Response[v1.CreateDecisionResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("gastown.v1.DecisionService.CreateDecision is not implemented"))
}

func (UnimplementedDecisionServiceHandler) Resolve(context.Context, *connect.Request[v1.ResolveRequest]) (*connect.Response[v1.ResolveResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("gastown.v1.DecisionService.Resolve is not implemented"))
}

func (UnimplementedDecisionServiceHandler) Cancel(context.Context, *connect.Request[v1.CancelRequest]) (*connect.Response[v1.CancelResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("gastown.v1.DecisionService.Cancel is not implemented"))
}

func (UnimplementedDecisionServiceHandler) WatchDecisions(context.Context, *connect.Request[v1.WatchDecisionsRequest], *connect.ServerStream[v1.Decision]) error {
	return connect.NewError(connect.CodeUnimplemented, errors.New("gastown.v1.DecisionService.WatchDecisions is not implemented"))
}
